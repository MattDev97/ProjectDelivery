[gd_scene load_steps=35 format=3 uid="uid://5pic6fxx6et3"]

[ext_resource type="PackedScene" uid="uid://ddqak780cwwfj" path="res://addons/resources_spreadsheet_view/typed_editors/dock_enum_array.tscn" id="8_234wn"]
[ext_resource type="PackedScene" uid="uid://c3a2cip8ffccv" path="res://addons/resources_spreadsheet_view/typed_editors/dock_array.tscn" id="9_nts08"]
[ext_resource type="PackedScene" uid="uid://b3a3bo6cfyh5t" path="res://addons/resources_spreadsheet_view/typed_editors/dock_color.tscn" id="10_nsma2"]
[ext_resource type="PackedScene" uid="uid://gtbf7b0wptv" path="res://addons/resources_spreadsheet_view/typed_editors/dock_number.tscn" id="11_q1ao4"]
[ext_resource type="PackedScene" uid="uid://rww3gpl052bn" path="res://addons/resources_spreadsheet_view/typed_editors/dock_texture.tscn" id="12_4kr6q"]
[ext_resource type="PackedScene" uid="uid://dhunxgcae6h1" path="res://addons/resources_spreadsheet_view/settings_grid.tscn" id="13_as1sh"]
[ext_resource type="PackedScene" uid="uid://p6x03dbvhnqw" path="res://addons/resources_spreadsheet_view/typed_editors/dock_dict.tscn" id="13_il556"]
[ext_resource type="PackedScene" uid="uid://b413igx28kkvb" path="res://addons/resources_spreadsheet_view/import_export/import_export_dialog.tscn" id="14_3p12b"]
[ext_resource type="PackedScene" uid="uid://b51hnttsie7k5" path="res://addons/resources_spreadsheet_view/main_screen/selection_actions.tscn" id="23_m53sx"]

[sub_resource type="GDScript" id="GDScript_w5ufo"]
script/source = "@tool
extends Control

signal grid_updated()

const TablesPluginSettingsClass := preload(\"res://addons/resources_spreadsheet_view/settings_grid.gd\")

@onready var node_folder_path : LineEdit = $\"HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer/Path\"
@onready var node_recent_paths : OptionButton = $\"HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer2/RecentPaths\"
@onready var node_table_root : Container = $\"HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/Scroll/MarginContainer/TableGrid\"
@onready var node_columns : HBoxContainer = $\"HeaderContentSplit/VBoxContainer/Columns/Columns\"
@onready var node_page_manager : Control = $\"HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages\"
@onready var node_class_filter : Control = $\"HeaderContentSplit/VBoxContainer/Search/Search/Class\"

@onready var _on_cell_gui_input : Callable = $\"InputHandler\"._on_cell_gui_input
@onready var _selection := $\"SelectionManager\"

var editor_interface : Object
var editor_plugin : EditorPlugin

var current_path := \"\"
var save_data_path : String = get_script().resource_path.get_base_dir() + \"/saved_state.json\"
var sorting_by := &\"\"
var sorting_reverse := false

var columns : Array[StringName] = []
var column_types : Array[int] = []
var column_hints : Array[int] = []
var column_hint_strings : Array[PackedStringArray] = []
var rows := []
var remembered_paths := {}
var remembered_paths_total_count := 0
var table_functions_dict := {}

var search_cond : Callable
var io : RefCounted

var first_row := 0
var last_row := 0


func _ready():
	editor_interface.get_resource_filesystem().filesystem_changed.connect(_on_filesystem_changed)
	if FileAccess.file_exists(save_data_path):
		var file := FileAccess.open(save_data_path, FileAccess.READ)
		var as_text := file.get_as_text()
		var as_var := JSON.parse_string(as_text)

		node_recent_paths.load_paths(as_var.get(&\"recent_paths\", []))
		node_columns.column_properties = as_var.get(&\"column_properties\", {})
		table_functions_dict = as_var.get(&\"table_functions\", {})
		for x in $\"HeaderContentSplit/VBoxContainer/Search/Search\".get_children():
			if x.has_method(&\"load_saved_functions\"):
				x.load_saved_functions(table_functions_dict)

		# Legacy compat: old hidden column format
		var legacy_hidden_columns : Dictionary = as_var.get(&\"hidden_columns\", {})
		for k in legacy_hidden_columns:
			for k2 in legacy_hidden_columns[k]:
				node_columns.column_properties[k] = node_columns.column_properties.get(k, {})
				node_columns.column_properties[k][k2] = { &\"visibility\" : 0 }

	if node_recent_paths.recent_paths.size() >= 1:
		display_folder(node_recent_paths.recent_paths[-1], &\"resource_name\", false, true)


func save_data():
	if (
		node_recent_paths.recent_paths.is_empty()
		and node_columns.column_properties.is_empty()
		and table_functions_dict.is_empty()
	):
		return

	var file := FileAccess.open(save_data_path, FileAccess.WRITE)
	file.store_string(JSON.stringify(
		{
			&\"recent_paths\" : node_recent_paths.recent_paths,
			&\"column_properties\" : node_columns.column_properties,
			&\"table_functions\" : table_functions_dict,
		}
	, \"  \"))


func _on_filesystem_changed():
	if current_path == \"\":
		return

	var file_total_count := _get_file_count_recursive(current_path)
	if file_total_count != remembered_paths_total_count:
		refresh()

	else:
		for k in remembered_paths:
			if !is_instance_valid(remembered_paths[k]):
				continue

			if remembered_paths[k].resource_path != k:
				var res = remembered_paths[k]
				remembered_paths.erase(k)
				remembered_paths[res.resource_path] = res
				refresh()
				break


func _get_file_count_recursive(path : String) -> int:
	var editor_fs : EditorFileSystem = editor_interface.get_resource_filesystem()
	var path_dir := editor_fs.get_filesystem_path(path)
	if !path_dir: return 0

	var file_total_count := 0
	var folder_stack : Array[EditorFileSystemDirectory] = [path_dir]
	while folder_stack.size() > 0:
		path_dir = folder_stack.pop_back()
		file_total_count += path_dir.get_file_count()
		for i in path_dir.get_subdir_count():
			folder_stack.append(path_dir.get_subdir(i))

	return file_total_count


func display_folder(folderpath : String, sort_by : StringName = \"\", sort_reverse : bool = false, force_rebuild : bool = false, is_echo : bool = false):
	if folderpath == \"\":
		# You wouldn't just wanna edit ALL resources in the project, that's a long time to load!
		return

	if sort_by == \"\":
		sort_by = &\"resource_path\"

	if folderpath.get_extension() == \"\":
		folderpath = folderpath.trim_suffix(\"/\") + \"/\"

	if (folderpath.ends_with(\".tres\") or folderpath.ends_with(\".res\")) and !(load(folderpath) is ResourceTablesImport):
		folderpath = folderpath.get_base_dir() + \"/\"

	node_recent_paths.add_path_to_recent(folderpath)
	node_folder_path.text = folderpath

	_load_resources_from_path(folderpath, sort_by, sort_reverse)
	_update_visible_rows(force_rebuild or current_path != folderpath)

	current_path = folderpath
	remembered_paths_total_count = _get_file_count_recursive(folderpath)
	node_columns.update()
	grid_updated.emit()

	$\"HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/Label\".visible = rows.size() == 0
	$\"HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/Label\".text = \"No rows visible?\\nThis might happen when sorting by a property that isn't here anymore.\\nTry clicking a column header to sort again!\\n\\nIt's also possible that your Filter expression is filtering them out.\"


func display_resources(resource_array : Array):
	if sorting_by == \"\":
		sorting_by = &\"resource_path\"

	current_path = \"\"
	node_recent_paths.select(-1)
	rows = []
	for x in resource_array:
		insert_row_sorted(x, rows, sorting_by, sorting_reverse)

	fill_property_data_many(rows)
	_update_visible_rows()

	node_columns.update()
	grid_updated.emit()


func refresh(force_rebuild : bool = true):
	if current_path == \"\":
		display_resources(rows)

	else:
		display_folder(current_path, sorting_by, sorting_reverse, force_rebuild)


func _load_resources_from_path(path : String, sort_by : StringName, sort_reverse : bool):
	if path.ends_with(\"/\"):
		io = ResourceTablesEditFormatTres.new()

	else:
		var loaded := load(path)
		if loaded is ResourceTablesImport:
			io = loaded.view_script.new()
			node_class_filter.hide()

		else:
			io = ResourceTablesEditFormatTres.new()
	
	io.editor_view = self
	remembered_paths.clear()
	rows = io.import_from_path(path, insert_row_sorted, sort_by, sort_reverse)


func _update_visible_rows(force_rebuild : bool = true):
	node_page_manager.update_page_count(rows)
	if columns.size() == 0:
		return

	if force_rebuild or columns != node_columns.columns:
		for x in node_table_root.get_children():
			x.free()

		node_columns.columns = columns

	var cells_left_to_free : int = node_table_root.get_child_count() - (last_row - first_row) * columns.size()
	while cells_left_to_free > 0:
		node_table_root.get_child(0).free()
		cells_left_to_free -= 1
	
	var color_rows : bool = ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"color_rows\")
	for i in last_row - first_row:
		_update_row(first_row + i, color_rows)


func fill_property_data(res : Resource):
	columns.clear()
	column_types.clear()
	column_hints.clear()
	column_hint_strings.clear()
	var column_values := []
	var i := -1
	for x in res.get_property_list():
		if can_display_property(x):
			i += 1
			columns.append(x[&\"name\"])
			column_types.append(x[&\"type\"])
			column_hints.append(x[&\"hint\"])
			column_hint_strings.append(x[&\"hint_string\"].split(\",\"))
			column_values.append(io.get_value(res, columns[i]))

	_selection.initialize_editors(column_values, column_types, column_hints)


func fill_property_data_many(resources : Array):
	node_class_filter.fill(resources)

	columns.clear()
	column_types.clear()
	column_hints.clear()
	column_hint_strings.clear()
	var column_values := []
	var i := -1
	var found_props := {}
	for x in resources:
		if x == null: continue
		i += 1
		if not search_cond.is_null() and not search_cond.call(x, i):
			continue

		if not node_class_filter.filter(x):
			continue

		for y in x.get_property_list():
			found_props[y[&\"name\"]] = y
			y[&\"owner_object\"] = x

	i = -1
	for x in found_props.values():
		if can_display_property(x):
			i += 1
			columns.append(x[&\"name\"])
			column_types.append(x[&\"type\"])
			column_hints.append(x[&\"hint\"])
			column_hint_strings.append(x[&\"hint_string\"].split(\",\"))
			column_values.append(io.get_value(x[&\"owner_object\"], columns[i]))

	_selection.initialize_editors(column_values, column_types, column_hints)


func can_display_property(property_info : Dictionary):
	var prop_type : int = property_info[&\"type\"]
	return (
		prop_type != TYPE_CALLABLE
		and prop_type != TYPE_SIGNAL
		and property_info[&\"usage\"] & PROPERTY_USAGE_EDITOR != 0
		and property_info[&\"name\"] != \"script\"
	)


func insert_row_sorted(res : Resource, loaded_rows : Array, sort_by : StringName, sort_reverse : bool):
	if not search_cond.is_null() and not search_cond.call(res, loaded_rows.size()):
		return

	if not sort_by in res or not node_class_filter.filter(res):
		return

	var sort_value = res[sort_by]
	for i in loaded_rows.size():
		if sort_reverse == compare_values(sort_value, loaded_rows[i][sort_by]):
			loaded_rows.insert(i, res)
			return
	
	remembered_paths[res.resource_path] = res
	loaded_rows.append(res)


func compare_values(a, b) -> bool:
	if a == null or b == null: return b == null
	if a is float or a is int:
		return a > b

	if a is Color:
		return a.h > b.h if a.h != b.h else a.v > b.v

	if a is Resource:
		return a.resource_path > b.resource_path

	return str(a).filenocasecmp_to(str(b)) > 0


func column_can_solo_open(column_index : int) -> bool:
	return (
		column_types[column_index] == TYPE_OBJECT
		or (column_types[column_index] == TYPE_ARRAY and column_hint_strings[column_index][0].begins_with(\"24\"))
	)


func column_solo_open(column_index : int):
	display_folder(current_path.trim_suffix(\"/\") + \"::\" + columns[column_index])


func _set_sorting(sort_by : StringName):
	var sort_reverse : bool = !(sorting_by != sort_by or sorting_reverse)
	sorting_reverse = sort_reverse
	sorting_by = sort_by
	refresh()


func _update_row(row_index : int, color_rows : bool = true):
	var current_node : Control
	var next_color := Color.WHITE
	var column_editors : Array = _selection.column_editors
	var shortened_path : String = rows[row_index].resource_path.substr(current_path.length()).trim_suffix(\".tres\").trim_suffix(\".res\")
	for i in columns.size():
		if node_table_root.get_child_count() <= (row_index - first_row) * columns.size() + i:
			current_node = column_editors[i].create_cell(self)
			current_node.gui_input.connect(_on_cell_gui_input.bind(current_node))
			node_table_root.add_child(current_node)

		else:
			current_node = node_table_root.get_child((row_index - first_row) * columns.size() + i)
			current_node.tooltip_text = (
				columns[i].capitalize()
				+ \"\\n---\\n\"
				+ \"Of \" + shortened_path
			)

		if columns[i] in rows[row_index]:
			current_node.mouse_filter = MOUSE_FILTER_STOP
			current_node.modulate.a = 1.0

		else:
			# Empty cell, can't click, property doesn't exist.
			current_node.mouse_filter = MOUSE_FILTER_IGNORE
			current_node.modulate.a = 0.0
			continue

		if columns[i] == &\"resource_path\":
			column_editors[i].set_value(current_node, shortened_path)

		else:			
			var cell_value = io.get_value(rows[row_index], columns[i])
			if cell_value != null or column_types[i] == TYPE_OBJECT:
				column_editors[i].set_value(current_node, cell_value)
				if color_rows and column_types[i] == TYPE_COLOR:
					next_color = cell_value

		column_editors[i].set_color(current_node, next_color)


func get_selected_column() -> int:
	return _selection.get_cell_column(_selection.edited_cells[0])


func select_column(column_index : int):
	_selection.deselect_all_cells()
	_selection.select_cell(Vector2i(column_index, 0))
	_selection.select_cells_to(Vector2i(column_index, rows.size() - 1))


func set_edited_cells_values_text(new_cell_values : Array):
	var column_editor : Object = _selection.column_editors[get_selected_column()]

	# Duplicated here since if using text editing, edited_cells_text needs to modified
	# but here, it would be converted from a String breaking editing
	var new_cell_values_converted := new_cell_values.duplicate()
	for i in new_cell_values.size():
		new_cell_values_converted[i] = column_editor.from_text(new_cell_values[i])

	set_edited_cells_values(new_cell_values_converted)
	for i in new_cell_values.size():
		var i_pos : Vector2i = _selection.edited_cells[i]
		var update_cell : Control = _selection.get_cell_node_from_position(i_pos)
		if update_cell == null:
			continue

		column_editor.set_value(update_cell, new_cell_values[i])


func set_edited_cells_values(new_cell_values : Array):
	var edited_rows : Array = _selection.get_edited_rows()
	var column : int = _selection.get_cell_column(_selection.edited_cells[0])
	var edited_cells_resources := _get_row_resources(edited_rows)

	editor_plugin.undo_redo.create_action(\"Set Cell Values\")
	editor_plugin.undo_redo.add_undo_method(
		self,
		&\"_update_resources\",
		edited_cells_resources.duplicate(),
		edited_rows.duplicate(),
		column,
		get_edited_cells_values()
	)
	editor_plugin.undo_redo.add_undo_method(
		_selection,
		&\"_update_selected_cells_text\"
	)
	editor_plugin.undo_redo.add_do_method(
		self,
		&\"_update_resources\",
		edited_cells_resources.duplicate(),
		edited_rows.duplicate(),
		column,
		new_cell_values.duplicate()
	)
	editor_plugin.undo_redo.commit_action(true)
	_selection._update_selected_cells_text()


func rename_row(row, new_name):
	if !has_row_names(): return
		
	io.rename_row(row, new_name)
	refresh()


func duplicate_selected_rows(new_name : String):
	io.duplicate_rows(_get_row_resources(_selection.get_edited_rows()), new_name)
	refresh()


func delete_selected_rows():
	io.delete_rows(_get_row_resources(_selection.get_edited_rows()))
	refresh()
	refresh.call_deferred()


func has_row_names():
	return io.has_row_names()


func get_last_selected_row():
	return rows[_selection.get_cell_row(_selection.edited_cells[-1])]


func get_edited_cells_values() -> Array:
	var cells : Array = _selection.edited_cells.duplicate()
	var column_index : int = _selection.get_cell_column(cells[0])
	var result := []
	result.resize(cells.size())
	for i in cells.size():
		result[i] = io.get_value(rows[_selection.get_cell_row(cells[i])], columns[column_index])
	
	return result


func _update_resources(update_rows : Array, update_row_indices : Array[int], update_column : int, values : Array):
	var column_editor : Object = _selection.column_editors[update_column]
	for i in update_rows.size():
		var row := update_row_indices[i]
		io.set_value(
			update_rows[i],
			columns[update_column],
			values[i],
			row
		)
		var update_cell : Control = _selection.get_cell_node_from_position(Vector2i(update_column, row))
		if update_cell == null:
			continue

		column_editor.set_value(update_cell, values[i])
		var row_script : Object = update_rows[i].get_script()
		if row_script != null && row_script.is_tool():
			for column_i in columns.size():
				if column_i == update_column:
					continue

				var update_cell_c : Control = _selection.get_cell_node_from_position(Vector2i(column_i, row))
				if columns[column_i] != &\"resource_path\":
					_selection.column_editors[column_i].set_value(update_cell_c, update_rows[i].get(columns[column_i]))

		if values[i] == null:
			continue

		if column_types[update_column] == TYPE_COLOR:
			for j in columns.size() - update_column:
				if j != 0 and column_types[j + update_column] == TYPE_COLOR:
					break

				_selection.column_editors[j + update_column].set_color(
					_selection.get_cell_node_from_position(Vector2i(update_column + j, row)),
					values[i]
				)

	node_columns._update_column_sizes()
	io.save_entries(rows, update_row_indices)


func _on_path_text_submitted(new_text : String = \"\"):
	if new_text != \"\":
		current_path = new_text
		display_folder(new_text, \"\", false, true)

	else:
		refresh()


func _on_FileDialog_dir_selected(dir : String):
	node_folder_path.text = dir
	display_folder(dir)


func _get_row_resources(row_indices) -> Array:
	var arr := []
	arr.resize(row_indices.size())
	for i in arr.size():
		arr[i] = rows[row_indices[i]]

	return arr


func _on_File_pressed():
	node_folder_path.get_parent().get_parent().visible = !node_folder_path.get_parent().get_parent().visible


func _on_SearchProcess_pressed():
	$\"HeaderContentSplit/VBoxContainer/Search\".visible = !$\"HeaderContentSplit/VBoxContainer/Search\".visible
"

[sub_resource type="GDScript" id="GDScript_geuqq"]
script/source = "@tool
extends Control


func _ready():
	modulate = get_theme_color(\"accent_color\", \"Editor\")
"

[sub_resource type="Gradient" id="Gradient_8kp6w"]
offsets = PackedFloat32Array(0, 0.995413, 1)
colors = PackedColorArray(1, 1, 1, 0.490196, 1, 1, 1, 0.0458716, 1, 1, 1, 0)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_18il8"]
gradient = SubResource("Gradient_8kp6w")

[sub_resource type="GDScript" id="GDScript_n6ief"]
script/source = "@tool
extends Button

@export var icon_name := \"Node\" :
	set(v):
		icon_name = v
		if has_theme_icon(v, \"EditorIcons\"):
			icon = get_theme_icon(v, \"EditorIcons\")


func _ready():
	self.icon_name = (icon_name)
"

[sub_resource type="GDScript" id="GDScript_hnhyx"]
script/source = "@tool
extends OptionButton

@onready var editor_view := $\"../../../../..\"

var recent_paths := []


func _ready():
	item_selected.connect(_on_item_selected)


func load_paths(paths):
	clear()
	for x in paths:
		add_path_to_recent(x, true)

	selected = recent_paths.size() - 1


func add_path_to_recent(path : String, is_loading : bool = false):
	if path in recent_paths: return

	var idx_in_array := recent_paths.find(path)
	if idx_in_array != -1:
		remove_item(idx_in_array)
		recent_paths.remove_at(idx_in_array)
	
	recent_paths.append(path)
	add_item(path)
	select(get_item_count() - 1)

	if !is_loading:
		editor_view.save_data()


func remove_selected_path_from_recent():
	if get_item_count() == 0:
		return
	
	var idx_in_array := selected
	recent_paths.remove_at(idx_in_array)
	remove_item(idx_in_array)

	if get_item_count() != 0:
		select(0)
		editor_view.display_folder(recent_paths[0])
		editor_view.save_data()


func _on_item_selected(index : int):
	editor_view.current_path = recent_paths[index]
	editor_view.node_folder_path.text = recent_paths[index]
	editor_view.refresh()
"

[sub_resource type="GDScript" id="GDScript_n7jxd"]
script/source = "@tool
extends Control

@export var editor_view_path : NodePath

@export_enum(\"Filter\", \"Process\", \"Sort\") var mode := 0
@export var title := \"\"
@export var default_text := \"\":
	set(v):
		default_text = v
		if _textfield == null:
			await ready

		_textfield.text = v
@export_multiline var default_text_ml := \"\":
	set(v):
		default_text_ml = v
		if _textfield_ml == null:
			await ready

		_textfield_ml.text = v
@export var function_save_key := \"\"

var _textfield : LineEdit
var _textfield_ml : TextEdit
var _togglable_popup : PopupPanel
var _saved_function_index_label : Label

var _saved_functions : Array = []
var _saved_function_selected := -1


func load_saved_functions(func_dict : Dictionary):
	if !func_dict.has(function_save_key):
		func_dict[function_save_key] = [default_text_ml]

	_saved_functions = func_dict[function_save_key]
	_on_saved_function_selected(0)


func _ready():
	var toggle_button := Button.new()
	var popup_box := VBoxContainer.new()
	var popup_buttons_box := HBoxContainer.new()
	var title_label := Label.new()
	var submit_button := Button.new()
	var move_label := Label.new()
	var move_button_l := Button.new()
	var move_button_r := Button.new()
	_textfield = LineEdit.new()
	_togglable_popup = PopupPanel.new()
	_textfield_ml = TextEdit.new()
	_saved_function_index_label = Label.new()

	add_child(_textfield)
	add_child(toggle_button)
	_textfield.add_child(_togglable_popup)
	_togglable_popup.add_child(popup_box)
	popup_box.add_child(title_label)
	popup_box.add_child(_textfield_ml)
	popup_box.add_child(popup_buttons_box)
	popup_buttons_box.add_child(submit_button)
	popup_buttons_box.add_child(move_label)
	popup_buttons_box.add_child(move_button_l)
	popup_buttons_box.add_child(_saved_function_index_label)
	popup_buttons_box.add_child(move_button_r)

	title_label.text = title

	toggle_button.icon = get_theme_icon(\"Collapse\", \"EditorIcons\")
	toggle_button.pressed.connect(_on_expand_pressed)

	_textfield.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_textfield.text_submitted.connect(_on_text_submitted.unbind(1))

	_textfield_ml.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	_textfield_ml.size_flags_vertical = Control.SIZE_EXPAND_FILL

	submit_button.text = \"Run multiline!\"
	submit_button.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	submit_button.pressed.connect(_on_text_submitted)

	move_label.text = \"Choose saved:\"
	move_button_l.icon = get_theme_icon(\"PagePrevious\", \"EditorIcons\")
	move_button_l.pressed.connect(_on_saved_function_bumped.bind(-1))
	_on_saved_function_selected(0)
	move_button_r.icon = get_theme_icon(\"PageNext\", \"EditorIcons\")
	move_button_r.pressed.connect(_on_saved_function_bumped.bind(+1))



func _on_expand_pressed():
	_togglable_popup.popup(Rect2i(_textfield.get_screen_position(), Vector2(size.x, 256.0)))


func _on_text_submitted():
	[_table_filter, _table_process][mode].call()
	_saved_functions[_saved_function_selected] = _textfield_ml.text
	get_node(editor_view_path).save_data.call_deferred()


func _get_script_source_code(first_line : String):
	var new_text := \"\"
	if !_togglable_popup.visible:
		new_text = _textfield.text
		if new_text == \"\":
			new_text = default_text

		return first_line + \"\\treturn \" + new_text

	else:
		new_text = _textfield_ml.text
		if new_text == \"\":
			new_text = default_text_ml

		var text_split := new_text.split(\"\\n\")
		for i in text_split.size():
			text_split[i] = \"\\t\" + text_split[i]

		return first_line + \"\\n\".join(text_split)


func _table_filter():
	var new_script := GDScript.new()
	new_script.source_code = _get_script_source_code(\"static func can_show(res : Resource, index : int) -> bool:\\n\")
	new_script.reload()

	var editor_view := get_node(editor_view_path)
	editor_view.search_cond = new_script.can_show
	editor_view.refresh()


func _table_process():
	var new_script := GDScript.new()
	new_script.source_code = _get_script_source_code(\"static func get_result(value : Variant, res : Resource, all_res : Array[Resource], row_index : int) -> Variant:\\n\")
	new_script.reload()

	var editor_view := get_node(editor_view_path)
	var new_script_instance := new_script.new()
	var values : Array = editor_view.get_edited_cells_values()

	var edited_rows : Array[int] = editor_view._selection.get_edited_rows()
	var edited_resources := edited_rows.map(func(x): return editor_view.rows[x])
	for i in values.size():
		values[i] = new_script_instance.get_result(values[i], editor_view.rows[edited_rows[i]], edited_resources, i)

	editor_view.set_edited_cells_values(values)


func _on_saved_function_selected(new_index : int):
	if new_index < 0:
		new_index = 0

	if _saved_function_selected == _saved_functions.size() - 1 and _textfield_ml.text == default_text_ml:
		_saved_functions.resize(_saved_functions.size() - 1)

	elif _saved_function_selected >= 0:
		_saved_functions[_saved_function_selected] = _textfield_ml.text

	_saved_function_selected = new_index
	if new_index >= _saved_functions.size():
		_saved_functions.resize(new_index + 1)
		for i in _saved_functions.size():
			if _saved_functions[i] == null:
				_saved_functions[i] = default_text_ml

	_textfield_ml.text = _saved_functions[new_index]
	_saved_function_index_label.text = \"%d/%d\" % [new_index + 1, _saved_functions.size()]
	get_node(editor_view_path).save_data.call_deferred()


func _on_saved_function_bumped(increment : int):
	_on_saved_function_selected(_saved_function_selected + increment)
"

[sub_resource type="GDScript" id="GDScript_5btok"]
script/source = "@tool
extends Control

@onready var editor_view := $\"../../../../..\"
@onready var node_options := $\"Class\"
@onready var node_subclasses_check := $\"Subclasses\"

var found_builtins : Array[String] = []
var found_scripts : Array[Script] = []
var selected_builtin := &\"\"
var selected_script : Script
var selected_is_valid := false
var include_subclasses := true


func _ready():
	node_options.item_selected.connect(_on_item_selected)
	node_subclasses_check.toggled.connect(_on_subclasses_toggled)


func fill(resources : Array):
	node_options.clear()
	found_scripts.clear()
	found_builtins.clear()
	var class_set := {}
	for x in resources:
		class_set[x.get_script()] = true
		class_set[StringName(x.get_class())] = true
		var current_s : Script = x.get_script()
		while current_s != null:
			current_s = current_s.get_base_script()
			if class_set.has(current_s):
				break

			class_set[current_s] = true

		var current_c : StringName = x.get_class()
		while true:
			if current_c == &\"Resource\":
				break

			current_c = ClassDB.get_parent_class(current_c)
			if class_set.has(current_c):
				break

			class_set[current_c] = true

	class_set.erase(null)
	class_set.erase(\"Resource\")

	for k in class_set:
		if k is StringName:
			found_builtins.append(k)

		if k is Script:
			found_scripts.append(k)

	# Add builtins, then script classes, in order.
	node_options.add_item(\"<all>\")
	for x in found_builtins:
		node_options.add_item(x)
		if has_theme_icon(x, &\"EditorIcons\"):
			node_options.set_item_icon(-1, get_theme_icon(x, &\"EditorIcons\"))

		else:
			node_options.set_item_icon(-1, get_theme_icon(&\"Object\", &\"EditorIcons\"))

	for x in found_scripts:
		node_options.add_item(x.resource_path.get_file().get_basename().to_pascal_case())
		node_options.set_item_icon(-1, get_theme_icon(&\"Script\", &\"EditorIcons\"))

	node_options.add_item(\"\")

	# Filter is disabled if the already selected class is not in the set.
	if not class_set.has(selected_script) and not class_set.has(selected_builtin):
		selected_is_valid = false

	# When the list is cleared, text and icon are cleared too. Setting to -1 explicitly allows changing icon and label
	node_options.selected = -1
	if not selected_is_valid:
		node_options.set_item_icon(-1, null)

	elif selected_builtin == &\"\" or selected_builtin == &\"Resource\":
		node_options.set_item_icon(-1, get_theme_icon(\"Script\", \"EditorIcons\"))

	else:
		node_options.set_item_icon(-1, get_theme_icon(selected_builtin, \"EditorIcons\"))

	show()


func clear():
	selected_is_valid = false


func filter(resource : Resource) -> bool:
	if not selected_is_valid:
		return true

	if resource.get_class() != selected_builtin:
		if include_subclasses and selected_script == null:
			var cur_class := StringName(resource.get_class())
			while cur_class != &\"Object\":
				cur_class = ClassDB.get_parent_class(cur_class)
				if cur_class == selected_builtin:
					return true

		return false

	if selected_script != null and resource.get_script() != selected_script:
		if include_subclasses:
			var cur_class : Script = resource.get_script()
			while cur_class != null:
				cur_class = cur_class.get_base_script()
				if cur_class == selected_script:
					return true

		return false


	return true


func _on_item_selected(index : int):
	if index == 0:
		selected_builtin = &\"\"
		selected_script = null
		selected_is_valid = false

	elif index <= found_builtins.size():
		selected_builtin = found_builtins[index - 1]
		selected_script = null
		selected_is_valid = true

	elif index <= found_builtins.size() + found_scripts.size():
		selected_script = found_scripts[index - found_builtins.size() - 1]
		selected_builtin = selected_script.get_instance_base_type()
		selected_is_valid = true

	node_options.tooltip_text = \"Selected: %s\" % node_options.get_item_text(index)
	editor_view.refresh()


func _on_subclasses_toggled(state : bool):
	include_subclasses = state
	editor_view.refresh()
"

[sub_resource type="GDScript" id="GDScript_qnmyd"]
script/source = "@tool
extends HBoxContainer

@onready var node_editor_view_root : Control = $\"../../../..\"

var rows_per_page := 50
var current_page := 0


func update_page_count(array : Array) -> int:
	var page_count : int = (node_editor_view_root.rows.size() - 1) / rows_per_page + 1
	node_editor_view_root.first_row = min(current_page, page_count) * rows_per_page
	node_editor_view_root.last_row = min(node_editor_view_root.first_row + rows_per_page, array.size())
	return page_count


func _on_grid_updated():
	if node_editor_view_root.rows.size() == 0:
		return

	visible = true
	var page_count := update_page_count(node_editor_view_root.rows)
	var pagelist_node := $\"Scroll/Pagelist\"
	for x in pagelist_node.get_children():
		x.queue_free()
	
	var button_group := ButtonGroup.new()
	var btns := []
	btns.resize(page_count)
	for i in page_count:
		var btn := Button.new()
		btns[i] = btn
		btn.toggle_mode = true
		btn.button_group = button_group
		btn.text = str(i + 1)
		btn.pressed.connect(_on_button_pressed.bind(btn))
		btn.size_flags_vertical = SIZE_SHRINK_CENTER
		pagelist_node.add_child(btn)

	var pagelist_line := HSeparator.new()
	pagelist_line.size_flags_horizontal = SIZE_EXPAND_FILL
	pagelist_node.add_child(pagelist_line)
	btns[current_page].button_pressed = true

	var sort_property : StringName = node_editor_view_root.sorting_by
	if sort_property == \"\": sort_property = \"resource_path\"
	var sort_type : int = node_editor_view_root.column_types[node_editor_view_root.columns.find(sort_property)]
	var property_values := []
	property_values.resize(page_count)
	if(node_editor_view_root.rows.size() == 0):
		return

	for i in page_count:
		property_values[i] = node_editor_view_root.rows[i * rows_per_page].get(sort_property)

	if sort_type == TYPE_FLOAT or sort_type == TYPE_INT:
		for i in page_count:
			btns[i].text = str(property_values[i])
			
	elif sort_type == TYPE_COLOR:
		for i in page_count:
			btns[i].self_modulate = property_values[i] * 0.75 + Color(0.25, 0.25, 0.25, 1.0)
	
	elif sort_type == TYPE_STRING:
		var strings := []
		strings.resize(page_count)
		for i in page_count:
			strings[i] = property_values[i].get_file()
			if strings[i] == \"\":
				strings[i] = str(i)
			
		_fill_buttons_with_prefixes(btns, strings, page_count)
	
	elif sort_type == TYPE_OBJECT:
		var strings := []
		strings.resize(page_count + 1)
		for i in page_count:
			if is_instance_valid(property_values[i]):
				strings[i] = property_values[i].resource_path.get_file()
		
		_fill_buttons_with_prefixes(btns, strings, page_count)


func _fill_buttons_with_prefixes(btns : Array, strings : Array, page_count : int):
	for i in page_count:
		if strings[i] == null:
			continue

		if i == 0:
			btns[0].text = strings[0][0]
			continue

		for j in strings[i].length():
			if strings[i].unicode_at(j) != strings[i - 1].unicode_at(j):
				btns[i].text = strings[i].left(j + 1)
				btns[i - 1].text = strings[i - 1].left(max(j + 1, btns[i - 1].text.length()))
				break
	
	for i in page_count - 1:
		btns[i].text = btns[i].text + \"-\" + btns[i + 1].text

	btns[page_count - 1].text += \"-[End]\"


func _on_button_pressed(button):
	button.button_pressed = true
	current_page = button.get_index()
	_update_view()


func _on_LineEdit_value_changed(value):
	rows_per_page = value
	current_page = 0
	_update_view()


func _update_view():
	node_editor_view_root.refresh(false)
"

[sub_resource type="GDScript" id="GDScript_w5ie1"]
script/source = "@tool
extends Control

const TablesPluginSettingsClass := preload(\"res://addons/resources_spreadsheet_view/settings_grid.gd\")

@export var table_header_scene : PackedScene

@onready var editor_view : Control = $\"../../../..\"
@onready var hide_columns_button : MenuButton = $\"../../MenuStrip/VisibleCols\"
@onready var grid : Container = $\"../../../MarginContainer/FooterContentSplit/Panel/Scroll/MarginContainer/TableGrid\"


var hidden_columns := {}:
	get:
		var result := {}
		for k_path in column_properties:
			var result_one_path := {}
			result[k_path] = result_one_path
			for k_column in column_properties[k_path]:
				for k_property in column_properties[k_path][k_column]:
					if k_property == &\"visibility\" && [k_property]:
						result[k_path][k_column] = true

		return result
var column_properties := {}
var columns := []:
	set(v):
		columns = v
		for x in get_children():
			remove_child(x)
			x.queue_free()

		var new_node : Control
		for x in v:
			new_node = table_header_scene.instantiate()
			new_node.manager = self
			add_child(new_node)
			new_node.set_label(x)
			new_node.get_node(\"Button\").pressed.connect(editor_view._set_sorting.bind(x))
			_update_column_sizes()


func _ready():
	hide_columns_button\\
		.get_popup()\\
		.id_pressed\\
		.connect(_on_visible_cols_id_pressed)
	$\"../../../MarginContainer/FooterContentSplit/Panel/Scroll\"\\
		.get_h_scroll_bar()\\
		.value_changed\\
		.connect(_on_h_scroll_changed)


func update():
	_update_hidden_columns()
	_update_column_sizes()


func hide_column(column_index : int):
	set_column_property(column_index, &\"visibility\", 0)
	editor_view.save_data()
	update()


func set_column_property(column_index : int, property_key : StringName, property_value):
	var dict := column_properties
	if !dict.has(editor_view.current_path):
		dict[editor_view.current_path] = {}

	dict = dict[editor_view.current_path]	
	if !dict.has(columns[column_index]):
		dict[columns[column_index]] = {}

	dict = dict[columns[column_index]]
	dict[property_key] = property_value


func get_column_property(column_index : int, property_key : StringName, property_default = null):
	var dict := column_properties
	if !dict.has(editor_view.current_path):
		return property_default

	dict = dict[editor_view.current_path]	
	if !dict.has(columns[column_index]):
		return property_default

	dict = dict[columns[column_index]]
	return dict.get(property_key, property_default)


func select_column(column_index : int):
	editor_view.select_column(column_index)


func _update_column_sizes():
	if grid.get_child_count() == 0:
		return
		
	await get_tree().process_frame
	var column_headers := get_children()

	if grid.get_child_count() < column_headers.size(): return
	if column_headers.size() != columns.size():
		editor_view.refresh()
		return
	
	var clip_text : bool = ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"clip_headers\")
	var visible_column_minsizes : Array[float] = []
	for i in column_headers.size():
		var header = column_headers[i]
		if header.visible:
			header.get_child(0).clip_text = clip_text
			visible_column_minsizes.append(header.get_combined_minimum_size().x)

	grid.visible_column_minsizes = visible_column_minsizes
	await get_tree().process_frame

	# Abort if the node has been deleted since.
	if !is_instance_valid(column_headers[0]):
		return

	get_parent().custom_minimum_size.y = column_headers[0].get_combined_minimum_size().y
	var column_positions : Array = grid.visible_column_positions
	var i := 0
	for x in column_headers:
		if !x.visible:
			continue

		var pos : float = column_positions[i]
		x.position.x = pos
		x.size.x = column_positions[i + 1] - pos
		i += 1


func _update_hidden_columns():
	var current_path : String = editor_view.current_path
	var rows_shown : int = editor_view.last_row - editor_view.first_row

	if !column_properties.has(current_path):
		column_properties[current_path] = {
			\"resource_local_to_scene\" : { &\"visibility\" : 0 },
			\"resource_name\" : { &\"visibility\" : 0 },
			\"metadata/_custom_type_script\" : { &\"visibility\" : 0 },
		}
		editor_view.save_data()

	var visible_column_count := 0
	for i in columns.size():
		var column_visible : bool = get_column_property(i, &\"visibility\", 1) != 0
		get_child(i).visible = column_visible
		for j in rows_shown:
			grid.get_child(j * columns.size() + i).visible = column_visible

		if column_visible:
			visible_column_count += 1


func _on_h_scroll_changed(value):
	position.x = -value


func _on_visible_cols_about_to_popup():
	var popup := hide_columns_button.get_popup()
	popup.clear()
	popup.hide_on_checkable_item_selection = false
	for i in columns.size():
		popup.add_check_item(columns[i].capitalize(), i)
		popup.set_item_checked(i, get_column_property(i, &\"visibility\", 1) != 0)


func _on_visible_cols_id_pressed(id : int):
	var popup := hide_columns_button.get_popup()
	if popup.is_item_checked(id):
		popup.set_item_checked(id, false)
		set_column_property(id, &\"visibility\", 0)

	else:
		popup.set_item_checked(id, true)
		set_column_property(id, &\"visibility\", 1)

	editor_view.save_data()
	update()
"

[sub_resource type="GDScript" id="GDScript_r1whh"]
script/source = "@tool
extends HBoxContainer

var manager : Control


func set_label(label : String):
	$\"Button\".text = label.capitalize()
	$\"Button\".tooltip_text = label + \"\\nClick to sort.\"


func _ready():
	$\"Button\".gui_input.connect(_on_main_gui_input)
	$\"Button2\".about_to_popup.connect(_on_about_to_popup)
	$\"Button2\".get_popup().id_pressed.connect(_on_list_id_pressed)


func _on_about_to_popup():
	var menu_popup : PopupMenu = $\"Button2\".get_popup()
	menu_popup.clear()
	menu_popup.add_item(\"Select All\", 0)
	menu_popup.add_item(\"Hide\", 1)

	if !manager.editor_view.column_can_solo_open(get_index()):
		menu_popup.add_item(\"(not a Resource property)\", 2)
		menu_popup.set_item_disabled(2, true)
		menu_popup.add_separator(\"\", 3)

	else:
		menu_popup.add_item(\"Open Sub-Resources of Column\", 2)

		if manager.editor_view.get_edited_cells_values().size() == 0 or manager.editor_view.get_selected_column() != get_index():
			menu_popup.add_item(\"(none selected)\", 3)
			menu_popup.set_item_disabled(3, true)

		else:
			menu_popup.add_item(\"Open Sub-Resources in Selection\", 3)


func _on_main_gui_input(event : InputEvent):
	if event is InputEventMouseButton and event.pressed:
		var popup : Popup = $\"Button2\".get_popup()
		if event.button_index == MOUSE_BUTTON_RIGHT:
			_on_about_to_popup()
			popup.visible = !popup.visible
			popup.size = Vector2.ZERO
			popup.position = Vector2i(get_global_mouse_position()) + get_viewport().position

		else:
			popup.visible = false


func _on_list_id_pressed(id : int):
	match id:
		0:
			manager.select_column(get_index())
		1:
			manager.hide_column(get_index())
		2:
			manager.editor_view.column_solo_open(get_index())
		3:
			var resources_to_open_unique := {}
			for x in manager.editor_view.get_edited_cells_values():
				if x is Array:
					for y in x:
						resources_to_open_unique[y] = true

				if x is Resource:
					resources_to_open_unique[x] = true

			if resources_to_open_unique.size() > 0:
				manager.editor_view.display_resources(resources_to_open_unique.keys())
"

[sub_resource type="PackedScene" id="PackedScene_8w634"]
_bundled = {
"conn_count": 0,
"conns": PackedInt32Array(),
"editable_instances": [],
"names": PackedStringArray("Header", "HBoxContainer", "offset_right", "offset_bottom", "size_flags_horizontal", "script", "Button", "Button", "layout_mode", "size_flags_horizontal", "size_flags_vertical", "text", "clip_text", "Button2", "MenuButton", "layout_mode", "size_flags_horizontal", "script", "icon_name"),
"node_count": 3,
"node_paths": [NodePath("."), NodePath(".")],
"nodes": PackedInt32Array(-1, -1, 1, 0, -1, 4, 2, 0, 3, 1, 4, 2, 5, 3, 0, 1073741824, 0, 7, 6, -1, 5, 8, 4, 9, 5, 10, 6, 11, 7, 12, 8, 0, 1073741825, 0, 14, 13, -1, 4, 15, 9, 16, 10, 17, 11, 18, 12, 0),
"variants": [179.0, 31.0, 3, SubResource("GDScript_r1whh"), 2, 3, 0, "resource_name", true, 2, 9, SubResource("GDScript_n6ief"), "ArrowDown"],
"version": 3
}

[sub_resource type="GDScript" id="GDScript_lvb0l"]
script/source = "@tool
extends Container

var visible_column_minsizes : Array = []:
	set(v):
		visible_column_minsizes = v
		queue_sort()
var visible_column_positions : Array[float] = []
var _cached_minimum_size := Vector2.ZERO


func _notification(what : int) -> void:
	if what == NOTIFICATION_SORT_CHILDREN:
		var visible_children : Array[Control] = []
		for x in get_children():
			if x is Control and x.visible:
				visible_children.append(x)

		sort_children(visible_children)


func _get_minimum_size() -> Vector2:
	return _cached_minimum_size


func get_visible_column_position(index : int):
	pass


func sort_children(children : Array[Control]) -> void:
	var column_count := visible_column_minsizes.size()
	if column_count == 0:
		return

	var column_minsizes : Array[float] = []
	var row_minsizes : Array[float] = []
	column_minsizes.resize(column_count)
	row_minsizes.resize(children.size() / column_count + 1)

	for i in visible_column_minsizes.size():
		column_minsizes[i] = visible_column_minsizes[i]

	var current_cell := Vector2i.ZERO
	for x in children:
		var minsize := x.get_combined_minimum_size()
		column_minsizes[current_cell.x] = maxf(column_minsizes[current_cell.x], minsize.x)
		row_minsizes[current_cell.y] = maxf(row_minsizes[current_cell.y], minsize.y)
		current_cell.x += 1
		if current_cell.x == column_count:
			current_cell.x = 0
			current_cell.y += 1

	var current_pos := Vector2.ZERO
	current_cell = Vector2i.ZERO
	for x in children:
		var cur_size := Vector2(column_minsizes[current_cell.x], row_minsizes[current_cell.y])
		fit_child_in_rect(x, Rect2(current_pos, cur_size))
		current_pos.x += cur_size.x
		current_cell.x += 1
		if current_cell.x == column_count:
			current_cell.x = 0
			current_cell.y += 1
			current_pos.x = 0.0
			current_pos.y += cur_size.y

	_cached_minimum_size = Vector2.ZERO
	visible_column_positions.resize(column_minsizes.size() + 1)
	for i in column_minsizes.size():
		_cached_minimum_size.x += column_minsizes[i]
		visible_column_positions[i + 1] = _cached_minimum_size.x

	for x in row_minsizes:
		_cached_minimum_size.y += x
"

[sub_resource type="GDScript" id="GDScript_de2be"]
script/source = "@tool
extends ColorRect

const TablesPluginSettingsClass := preload(\"res://addons/resources_spreadsheet_view/settings_grid.gd\")

@onready var editor_view : Control = $\"../../../../../..\"
@onready var grid_scroll : ScrollContainer = $\"../../Scroll\"
@onready var grid : Container = $\"../../Scroll/MarginContainer/TableGrid\"

var children : Array[Control] = []
var children_copy_cells : Array[Control] = []


func _ready() -> void:
	grid_scroll.get_h_scroll_bar().value_changed.connect(_on_scroll_updated, CONNECT_DEFERRED)
	grid_scroll.get_v_scroll_bar().value_changed.connect(_on_scroll_updated, CONNECT_DEFERRED)


func _on_grid_updated() -> void:
	if editor_view.rows.size() == 0:
		hide()
		return

	visible = ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"freeze_first_column\")
	for x in get_children():
		x.queue_free()

	children.clear()
	children_copy_cells.clear()
	size.x = 0.0

	await get_tree().process_frame

	var first_visible_column := 0
	for i in editor_view.columns.size():
		if grid.get_child(i).visible:
			first_visible_column = i
			break

	var total_column_count : int = editor_view.columns.size()
	children.resize(grid.get_child_count() / total_column_count)
	children_copy_cells.resize(children.size())
	for i in children.size():
		children_copy_cells[i] = grid.get_child(total_column_count * i + first_visible_column)
		children[i] = children_copy_cells[i].duplicate()
		children[i].mouse_filter = Control.MOUSE_FILTER_IGNORE
		add_child(children[i])
		size.x = maxf(size.x, children_copy_cells[i].size.x)

	size.y = grid.size.y
	color = get_theme_color(&\"background\", &\"Editor\")
	color.a *= 0.9
	_on_scroll_updated(0.0)


func _on_scroll_updated(_new_value : float):
	position = Vector2(0.0, -grid_scroll.scroll_vertical)
	for i in children.size():
		children[i].size = children_copy_cells[i].size
		children[i].position = children_copy_cells[i].position
"

[sub_resource type="GDScript" id="GDScript_1pwr0"]
script/source = "@tool
extends Node

const TablesPluginEditorViewClass := preload(\"res://addons/resources_spreadsheet_view/editor_view.gd\")
const TablesPluginSelectionManagerClass := preload(\"res://addons/resources_spreadsheet_view/main_screen/selection_manager.gd\")
const TextEditingUtilsClass := preload(\"res://addons/resources_spreadsheet_view/text_editing_utils.gd\")

@onready var editor_view : TablesPluginEditorViewClass = get_parent()
@onready var selection : TablesPluginSelectionManagerClass = get_node(\"../SelectionManager\")


func _on_cell_gui_input(event : InputEvent, cell_node : Control):
	var cell := selection.get_cell_node_position(cell_node)
	if event is InputEventMouseButton:
		editor_view.grab_focus()
		if event.button_index == MOUSE_BUTTON_RIGHT and event.pressed:
			if !cell in selection.edited_cells:
				selection.deselect_all_cells()
				selection.select_cell(cell)

			selection.rightclick_cells()

		if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
			if event.is_command_or_control_pressed():
				if cell in selection.edited_cells:
					selection.deselect_cell(cell)

				else:
					selection.select_cell(cell)

			elif Input.is_key_pressed(KEY_SHIFT):
				selection.select_cells_to(cell)

			else:
				selection.deselect_all_cells()
				selection.select_cell(cell)


func _gui_input(event : InputEvent):
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_RIGHT and event.is_pressed():
			selection.rightclick_cells()

		if event.button_index == MOUSE_BUTTON_LEFT:
			editor_view.grab_focus()
			if !event.pressed:
				selection.deselect_all_cells()


func _input(event : InputEvent):
	if !event is InputEventKey or !event.pressed:
		return
	
	if !editor_view.has_focus() or selection.edited_cells.size() == 0:
		return

	if event.keycode == KEY_CTRL or event.keycode == KEY_SHIFT or event.keycode == KEY_META:
		# Modifier keys do not get processed.
		return
	
	# Ctrl + Z (before, and instead of, committing the action!)
	if event.is_command_or_control_pressed():
		if event.keycode == KEY_Z or event.keycode == KEY_Y:
			return

	_key_specific_action(event)
	editor_view.grab_focus()
	editor_view.editor_interface.get_resource_filesystem().scan()


func _key_specific_action(event : InputEvent):
	var column := selection.get_cell_column(selection.edited_cells[0])
	var ctrl_pressed : bool = event.is_command_or_control_pressed()

	# BETWEEN-CELL NAVIGATION
	var grid_move_offset := (10 if ctrl_pressed else 1)
	if event.keycode == KEY_UP:
		_move_selection_on_grid(0, -grid_move_offset)

	elif event.keycode == KEY_DOWN:
		_move_selection_on_grid(0, +grid_move_offset)

	elif Input.is_key_pressed(KEY_SHIFT) and event.keycode == KEY_TAB:
		_move_selection_on_grid(-grid_move_offset, 0)
	
	elif event.keycode == KEY_TAB:
		_move_selection_on_grid(+grid_move_offset, 0)

	elif ctrl_pressed and event.keycode == KEY_C:
		TextEditingUtilsClass.multi_copy(selection.edited_cells_text)
		get_viewport().set_input_as_handled()

	# Ctrl + V
	elif ctrl_pressed and event.keycode == KEY_V and editor_view.columns[column] != \"resource_path\":
		selection.clipboard_paste()
		get_viewport().set_input_as_handled()

	# TEXT CARET MOVEMENT
	var caret_move_offset := TextEditingUtilsClass.get_caret_movement_from_key(event.keycode)
	if TextEditingUtilsClass.multi_move_caret(caret_move_offset, selection.edited_cells_text, selection.edit_cursor_positions, ctrl_pressed):
		selection.queue_redraw()
		return

	# The following actions do not work on non-editable cells.
	if !selection.column_editors[column].is_text() or editor_view.columns[column] == \"resource_path\":
		return
	
	# ERASING
	elif event.keycode == KEY_BACKSPACE:
		editor_view.set_edited_cells_values_text(TextEditingUtilsClass.multi_erase_left(
			selection.edited_cells_text, selection.edit_cursor_positions, ctrl_pressed
		))

	elif event.keycode == KEY_DELETE:
		editor_view.set_edited_cells_values_text(TextEditingUtilsClass.multi_erase_right(
			selection.edited_cells_text, selection.edit_cursor_positions, ctrl_pressed
		))
		get_viewport().set_input_as_handled()

	# And finally, text typing.
	elif event.keycode == KEY_ENTER:
		editor_view.set_edited_cells_values_text(TextEditingUtilsClass.multi_input(
			\"\\n\", selection.edited_cells_text, selection.edit_cursor_positions
		))

	elif event.unicode != 0 and event.unicode != 127:
		editor_view.set_edited_cells_values_text(TextEditingUtilsClass.multi_input(
			char(event.unicode), selection.edited_cells_text, selection.edit_cursor_positions
		))

	selection.queue_redraw()


func _move_selection_on_grid(move_h : int, move_v : int):
	var selected_cells := selection.edited_cells.duplicate()
	var num_columns := editor_view.columns.size()
	var num_rows := editor_view.rows.size()
	var new_child_pos := Vector2i(0, 0)
	for i in selected_cells.size():
		new_child_pos = selected_cells[i]
		for move_count in 1000:
			if move_v != 0 and (new_child_pos.y + move_v >= num_rows or new_child_pos.y + move_v < 0):
				break

			new_child_pos.x += move_h
			new_child_pos.y += move_v
			if new_child_pos.x < 0:
				new_child_pos.x = num_columns - 1
				if new_child_pos.y > 0:
					new_child_pos.y -= 1

			if new_child_pos.x >= num_columns:
				new_child_pos.x = 0
				if new_child_pos.y < num_rows - 1:
					new_child_pos.y += 1

			if selection.get_cell_node_from_position(new_child_pos) == null:
				break

			if selection.get_cell_node_from_position(new_child_pos).is_visible_in_tree():
				break

		selected_cells[i] = new_child_pos

	editor_view.grab_focus()
	selection.deselect_all_cells()
	selection.select_cells(selected_cells)
"

[sub_resource type="GDScript" id="GDScript_x8y6m"]
script/source = "@tool
extends Control

signal cells_selected(cells_positions)
signal cells_rightclicked(cells_positions)

const EditorViewClass := preload(\"res://addons/resources_spreadsheet_view/editor_view.gd\")
const TextEditingUtilsClass := preload(\"res://addons/resources_spreadsheet_view/text_editing_utils.gd\")

@export var cell_editor_classes : Array[Script] = []

@onready var node_property_editors : VBoxContainer = $\"../HeaderContentSplit/MarginContainer/FooterContentSplit/Footer/PropertyEditors\"
@onready var scrollbar : ScrollContainer = $\"../HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/Scroll\"

@onready var editor_view : EditorViewClass = get_parent()

var edited_cells : Array = []
var edited_cells_text : Array = []
var edit_cursor_positions : Array[int] = []

var all_cell_editors : Array = []
var column_editors : Array[Object] = []
var inspector_resource : Resource


func _ready():
	# Load cell editors and instantiate them
	for x in cell_editor_classes:
		all_cell_editors.append(x.new())
		all_cell_editors[all_cell_editors.size() - 1].hint_strings_array = editor_view.column_hint_strings

	get_parent()\\
		.editor_interface\\
		.get_inspector()\\
		.property_edited\\
		.connect(_on_inspector_property_edited)

	scrollbar.get_h_scroll_bar().value_changed.connect(queue_redraw.unbind(1), CONNECT_DEFERRED)
	scrollbar.get_v_scroll_bar().value_changed.connect(queue_redraw.unbind(1), CONNECT_DEFERRED)

	if ProjectSettings.get_setting(editor_view.TablesPluginSettingsClass.PREFIX + \"fold_docks\", false):
		for x in node_property_editors.get_children():
			x.resize_set_hidden(true)


func _draw():
	if edited_cells.size() == 0 or edit_cursor_positions.size() != edited_cells.size() or !column_editors[edited_cells[0].x].is_text():
		return

	var font := get_theme_font(&\"font\", &\"Label\")
	var font_size := get_theme_font_size(&\"font\", &\"Label\")
	var caret_color := get_theme_color(&\"caret_color\", &\"LineEdit\")
	var label_padding_left := 2.0
	var newline_char := 10
	for i in edited_cells.size():
		var cell : Control = get_cell_node_from_position(edited_cells[i])
		var caret_rect := Rect2()
		if cell.has_method(&\"get_character_bounds\"):
			if edited_cells_text[i].length() == edit_cursor_positions[i]:
				caret_rect = cell.get_character_bounds(edit_cursor_positions[i] - 1)
				caret_rect.position.x += caret_rect.size.x

			else:
				caret_rect = cell.get_character_bounds(edit_cursor_positions[i])

			caret_rect.size.x = 1.0

		else:
			caret_rect = TextEditingUtilsClass.get_caret_rect(edited_cells_text[i], edit_cursor_positions[i], font, font_size, label_padding_left, 1.0)

		caret_rect.position += cell.global_position - global_position
		draw_rect(caret_rect, caret_color)


func initialize_editors(column_values, column_types, column_hints):
	_set_visible_selected(false)
	column_editors.clear()
	for i in column_values.size():
		for x in all_cell_editors:
			if x.can_edit_value(column_values[i], column_types[i], column_hints[i], i):
				column_editors.append(x)
				break


func deselect_all_cells():
	_set_visible_selected(false)
	edited_cells.clear()
	edited_cells_text.clear()
	edit_cursor_positions.clear()
	_selection_changed()


func deselect_cell(cell : Vector2i):
	var idx := edited_cells.find(cell)
	if idx == -1: return

	edited_cells.remove_at(idx)
	if edited_cells_text.size() != 0:
		edited_cells_text.remove_at(idx)
		edit_cursor_positions.remove_at(idx)

	var cell_node := get_cell_node_from_position(cell)
	if cell_node != null:
		column_editors[get_cell_column(cell)].set_selected(cell_node, false)

	_selection_changed()


func select_cell(cell : Vector2i):
	var column_index := get_cell_column(cell)
	if edited_cells.size() == 0 or edited_cells[0].x == cell.x:
		_add_cell_to_selection(cell)
		_try_open_docks(cell)
		inspector_resource = editor_view.rows[get_cell_row(cell)]
		editor_view.editor_plugin.get_editor_interface().edit_resource(inspector_resource)

	_selection_changed()


func select_cells(cells : Array):
	var last_selectible := Vector2i(-1, -1)
	var started_empty := edited_cells.size() == 0
	for x in cells:
		if started_empty or edited_cells[0].x != x.x:
			_add_cell_to_selection(x)
			if get_cell_node_from_position(x) != null:
				last_selectible = x

	if last_selectible != Vector2i(-1, -1):
		select_cell(last_selectible)


func select_cells_to(cell : Vector2i):
	var column_index := get_cell_column(cell)
	if edited_cells.size() == 0 or column_index != get_cell_column(edited_cells[-1]):
		return
	
	var row_start := get_cell_row(edited_cells[-1])
	var row_end := get_cell_row(cell)
	var edge_shift := -1 if row_start > row_end else 1
	row_start += edge_shift
	row_end += edge_shift

	var column_editor := column_editors[column_index]
	for i in range(row_start, row_end, edge_shift):
		var cur_cell := Vector2i(column_index, i)
		var cur_cell_node := get_cell_node_from_position(cur_cell)
		if cur_cell not in edited_cells:
			edited_cells.append(cur_cell)

			var cur_cell_value = editor_view.io.get_value(editor_view.rows[cur_cell.y], editor_view.columns[cur_cell.x])
			var cur_cell_text : String = column_editor.to_text(cur_cell_value)
			edited_cells_text.append(cur_cell_text)
			edit_cursor_positions.append(cur_cell_text.length())

		if cur_cell_node == null or !cur_cell_node.visible or cur_cell_node.mouse_filter == MOUSE_FILTER_IGNORE:
			# When showing several classes, empty cells will be non-selectable.
			continue

		column_editors[column_index].set_selected(cur_cell_node, true)

	_selection_changed()


func rightclick_cells():
	cells_rightclicked.emit(edited_cells)


func is_cell_node_selected(cell : Control) -> bool:
	return get_cell_node_position(cell) in edited_cells


func is_cell_selected(cell : Vector2i) -> bool:
	return cell in edited_cells


func can_select_cell(cell : Vector2i) -> bool:
	if edited_cells.size() == 0:
		return true

	if (
		get_cell_column(cell)
		!= get_cell_column(edited_cells[0])
	):
		return false

	return !cell in edited_cells


func get_cell_node_from_position(cell_pos : Vector2i) -> Control:
	var cell_index := (cell_pos.y - editor_view.first_row) * editor_view.columns.size() + cell_pos.x
	if cell_index < 0 or cell_index >= editor_view.node_table_root.get_child_count():
		return null

	return editor_view.node_table_root.get_child(cell_index)


func get_cell_node_position(cell : Control) -> Vector2i:
	var col_count := editor_view.columns.size()
	var cell_index := cell.get_index()
	return Vector2i(cell_index % col_count, cell_index / col_count + editor_view.first_row)


func get_cell_column(cell : Vector2i) -> int:
	return cell.x


func get_cell_row(cell : Vector2i) -> int:
	return cell.y


func get_edited_rows() -> Array[int]:
	var rows : Array[int] = []
	rows.resize(edited_cells.size())
	for i in rows.size():
		rows[i] = get_cell_row(edited_cells[i])

	return rows


func clipboard_paste():
	if column_editors[edited_cells[0].x].is_text():
		editor_view.set_edited_cells_values(
			TextEditingUtilsClass.multi_paste(
				edited_cells_text,
				edit_cursor_positions,
			)
		)

	elif DisplayServer.clipboard_has():
		var values := []
		values.resize(edited_cells.size())
		var pasted_lines := DisplayServer.clipboard_get().replace(\"\\r\", \"\").split(\"\\n\")
		var paste_each_line := pasted_lines.size() == values.size()

		for i in values.size():
			values[i] = str_to_var(
				pasted_lines[i] if paste_each_line else DisplayServer.clipboard_get()
			)

		editor_view.set_edited_cells_values(values)


func _selection_changed():
	queue_redraw()
	cells_selected.emit(edited_cells)


func _set_visible_selected(state : bool):	
	for x in edited_cells:
		var cell_node := get_cell_node_from_position(x)
		if cell_node != null:
			column_editors[get_cell_column(x)].set_selected(cell_node, state)


func _add_cell_to_selection(cell : Vector2i):
	if !edited_cells.has(cell):
		edited_cells.append(cell)

	var column_editor := column_editors[get_cell_column(cell)]
	var cell_node := get_cell_node_from_position(cell)
	if cell_node != null:
		column_editor.set_selected(cell_node, true)

	var cell_value = editor_view.io.get_value(editor_view.rows[cell.y], editor_view.columns[cell.x])
	var text_value : String = column_editor.to_text(cell_value)
	edited_cells_text.append(text_value)
	edit_cursor_positions.append(text_value.length())


func _update_selected_cells_text():
	if edited_cells_text.size() == 0:
		return

	var column_editor := column_editors[get_cell_column(edited_cells[0])]
	if !column_editor.text_update_on_edit():
		return

	for i in edited_cells.size():
		edited_cells_text[i] = column_editor.to_text(editor_view.io.get_value(
			editor_view.rows[edited_cells[i].y],
			editor_view.columns[edited_cells[i].x],
		))
		edit_cursor_positions[i] = edited_cells_text[i].length()


func _try_open_docks(cell : Vector2i):
	var column_index := get_cell_column(cell)
	var row = editor_view.rows[get_cell_row(cell)]
	var column := editor_view.columns[column_index]
	var type := editor_view.column_types[column_index]
	var hints := editor_view.column_hints[column_index]

	for x in node_property_editors.get_children():
		x.visible = x.try_edit_value(editor_view.io.get_value(row, column), type, hints)
		x.get_node(x.path_property_name).text = column


func _on_inspector_property_edited(property : StringName):
	if !editor_view.is_visible_in_tree(): return
	if inspector_resource != editor_view.editor_plugin.get_editor_interface().get_inspector().get_edited_object():
		return
	
	if editor_view.columns[get_cell_column(edited_cells[0])] != property:
		var columns := editor_view.columns
		var previously_edited := edited_cells.duplicate()
		var new_column := columns.find(property)
		deselect_all_cells()
		for i in previously_edited.size():
			_add_cell_to_selection(Vector2i(new_column, previously_edited[i].y))

	var new_value = inspector_resource[property]
	var values := []
	values.resize(edited_cells.size())
	values.fill(new_value)
	if new_value is Resource and new_value.resource_path == \"\":
		for i in values.size():
			values[i] = new_value.duplicate()

	editor_view.set_edited_cells_values.call_deferred(values)
	_try_open_docks(edited_cells[0])
"

[sub_resource type="GDScript" id="GDScript_7gp0s"]
script/source = "extends \"res://addons/resources_spreadsheet_view/typed_cells/cell_editor_array.gd\"


func can_edit_value(value, type, property_hint, column_index) -> bool:
	if (
		type != TYPE_PACKED_INT32_ARRAY
		and type != TYPE_PACKED_INT64_ARRAY
		and type != TYPE_ARRAY
	) or property_hint != PROPERTY_HINT_TYPE_STRING:
		return false
	
	return hint_strings_array[column_index][0].begins_with(\"2/2:\")


func _write_value_to_child(value, key, hint_arr : PackedStringArray, child : Label, color_tint : float, cell_label_mode : int):
	var value_str : String
	var key_found := -1
	for i in hint_arr.size():
		var colon_found := hint_arr[i].rfind(\":\")
		if colon_found == -1:
			key_found = value
			break

		if hint_arr[i].substr(colon_found + 1).to_int() == value:
			key_found = i
			break

	if key_found == 0:
		# Enum array hints have \"2/3:\" before list.
		var found := hint_arr[0].find(\":\") + 1
		value_str = hint_arr[0].substr(hint_arr[0].find(\":\") + 1)

	elif key_found != -1:
		value_str = hint_arr[key_found]

	else:
		value_str = \"?:%s\" % value

	super(value_str, value_str, hint_arr, child, color_tint, cell_label_mode)
"

[sub_resource type="GDScript" id="GDScript_fkfih"]
script/source = "extends \"res://addons/resources_spreadsheet_view/typed_cells/cell_editor_array.gd\"


func can_edit_value(value, type, property_hint, column_index) -> bool:
	return type == TYPE_DICTIONARY


func create_cell(caller : Control) -> Control:
	return load(CELL_SCENE_DIR + \"array.tscn\").instantiate()


func set_value(node : Control, value):
	if value.size() == 0:
		return

	var children := node.get_node(\"Box\").get_children()
	node.custom_minimum_size.x = ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"array_min_width\")
	var color_tint : float = 0.01 * ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"array_color_tint\", 100.0)
	var cell_label_mode : int = ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"resource_cell_label_mode\", 0)
	while children.size() < value.size():
		var new_label = Label.new()
		children.append(new_label)
		node.get_node(\"Box\").add_child(new_label)
	
	var column_hints : PackedStringArray = hint_strings_array[node.get_index() % hint_strings_array.size()]
	var values : Array = value.values()
	var keys : Array = value.keys()

	if values[0] is int || values[1] is int:
		# When a value is an enum, the dictionary is always types, so all keys/values are same type.
		for x in column_hints:
			if x.begins_with(\"2/2:\") || x.find(\"2/2:\") != -1:
				set_value_enum(node, value, children, keys, values, cell_label_mode, column_hints, color_tint)
				return

	for i in children.size():
		if i >= values.size():
			children[i].visible = false

		else:
			children[i].visible = true
			var current_value = values[i]
			var current_key = keys[i]
			if current_value is Resource:
				current_value = _resource_to_string(current_value, cell_label_mode)

			if current_key is Resource:
				current_key = _resource_to_string(current_key, cell_label_mode)

			_write_value_to_child(\"%s  %s\" % [current_key, current_value], current_key, column_hints, children[i], color_tint, cell_label_mode)


func set_value_enum(node : Control, value, children : Array[Node], keys : Array, values : Array, cell_label_mode : int, column_hints : PackedStringArray, color_tint : float) -> void:
	var key_enum_values : Dictionary[int, String] = {}
	var value_enum_values : Dictionary[int, String] = {}
	var parse_phase := 0
	for x in column_hints:
		var found_semicolon := x.rfind(\";\")
		if parse_phase == 0 && x.begins_with(\"2/2:\"):
			var split := x.split(\":\")
			parse_phase = 1
			key_enum_values[split[-1].to_int()] = \"%s:%s\" % [split[-2], split[-1]]

		elif parse_phase == 1 && found_semicolon != -1:
			if x.find(\"2/2:\") == -1:
				var split := x.left(found_semicolon).split(\":\")
				key_enum_values[split[-1].to_int()] = \"%s:%s\" % [split[-2], split[-1]]
				break

			else:
				var split := x.split(\":\")
				if parse_phase == 1:
					key_enum_values[split[0].to_int()] = \"%s:%s\" % [split[0], split[1].left(found_semicolon - split[0].length() - 1)]

				parse_phase = 2
				value_enum_values[split[-1].to_int()] = \"%s:%s\" % [split[-2], split[-1]]

		elif parse_phase == 1:
			var found := x.find(\":\")
			key_enum_values[x.substr(found + 1).to_int()] = x

		elif parse_phase == 2:
			var found := x.find(\":\")
			value_enum_values[x.substr(found + 1).to_int()] = x

	for i in children.size():
		if i >= values.size():
			children[i].visible = false

		else:
			children[i].visible = true
			var current_value = value_enum_values.get(values[i], values[i])
			var current_key = key_enum_values.get(keys[i], keys[i])
			if current_value is Resource:
				current_value = _resource_to_string(current_value, cell_label_mode)

			if current_key is Resource:
				current_key = _resource_to_string(current_key, cell_label_mode)

			_write_value_to_child(\"%s  %s\" % [current_key, current_value], current_key, column_hints, children[i], color_tint, cell_label_mode)


func is_text():
	return false


func to_text(value) -> String:
	return var_to_str(value).replace(\"\\n\", \" \")


func from_text(text : String):
	return str_to_var(text)
"

[sub_resource type="GDScript" id="GDScript_kky4y"]
script/source = "extends ResourceTablesCellEditor

const TablesPluginSettingsClass := preload(\"res://addons/resources_spreadsheet_view/settings_grid.gd\")


func can_edit_value(value, type, property_hint, column_index) -> bool:
	return type == TYPE_PACKED_STRING_ARRAY or type == TYPE_ARRAY


func create_cell(caller : Control) -> Control:
	return load(CELL_SCENE_DIR + \"array.tscn\").instantiate()


func set_value(node : Control, value):
	var children := node.get_node(\"Box\").get_children()
	node.custom_minimum_size.x = ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"array_min_width\")
	var color_tint : float = 0.01 * ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"array_color_tint\", 100.0)
	var cell_label_mode : int = ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"resource_cell_label_mode\", 0)
	while children.size() < value.size():
		children.append(Label.new())
		node.get_node(\"Box\").add_child(children[children.size() - 1])
	
	var column_hints = hint_strings_array[node.get_index() % hint_strings_array.size()]
	for i in children.size():
		if i >= value.size():
			children[i].visible = false

		else:
			children[i].visible = true
			_write_value_to_child(value[i], value[i], column_hints, children[i], color_tint, cell_label_mode)


func _write_value_to_child(value, key, hint_arr : PackedStringArray, child : Label, color_tint : float, cell_label_mode : int):
	if value is Resource:
		value = _resource_to_string(value, cell_label_mode)

	if key is Resource:
		key = _resource_to_string(key, cell_label_mode)

	child.text = str(value)
	child.self_modulate = (
		Color.WHITE * (1.0 - color_tint)
		+
		(Color(str(key).hash()) + Color(0.2, 0.2, 0.2, 1.0)) * color_tint
	)


static func _resource_to_string(res : Resource, cell_label_mode : int):
	var prefix := \"\"
	if cell_label_mode != 2:
		if res.has_method(&\"_to_string\"):
			prefix = res._to_string() + \"\\n\"

		elif res.has_method(&\"ToString\"):
			prefix = res.ToString() + \"\\n\"

	if cell_label_mode == 1 && !prefix.is_empty():
		return prefix.trim_suffix(\"\\n\")

	return prefix + (res.resource_name if res.resource_name != \"\" else \"[%s]\" % res.resource_path.get_file())


func is_text():
	return false
"

[sub_resource type="GDScript" id="GDScript_sa58q"]
script/source = "extends ResourceTablesCellEditor

var _cached_color := Color.WHITE


func create_cell(caller : Control) -> Control:
	var node : Label = load(CELL_SCENE_DIR + \"basic.tscn\").instantiate()
	var color := ColorRect.new()
	node.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT
	node.custom_minimum_size.x = 56
	node.add_child(color)
	color.name = \"Color\"
	_resize_color_rect.call_deferred(color)
	return node


func _resize_color_rect(rect):
	if !is_instance_valid(rect): return  # Table refreshed twice, probably? Either way, this fix is easier
	rect.size = Vector2(8, 0)
	rect.set_anchors_and_offsets_preset(Control.PRESET_LEFT_WIDE, Control.PRESET_MODE_KEEP_WIDTH)


func can_edit_value(value, type, property_hint, property_hint_string) -> bool:
	return type == TYPE_COLOR


func set_value(node : Control, value):
	if value is String:
		node.text = TextEditingUtilsClass.show_non_typing(str(value))

	else:
		node.text = value.to_html(true)
		_cached_color = value

	node.get_node(\"Color\").color = value


func to_text(value) -> String:
	return value.to_html()


func from_text(text : String):
	return Color.from_string(text, Color.BLACK)
"

[sub_resource type="GDScript" id="GDScript_eb48a"]
script/source = "extends ResourceTablesCellEditor


func can_edit_value(value, type, property_hint, column_index) -> bool:
	return type == TYPE_BOOL


func set_value(node : Control, value):
	if value is bool:
		_set_value_internal(node, value)

	else:
		_set_value_internal(node, node.text.begins_with(\"O\"))


func _set_value_internal(node, value):
	node.text = \"ON\" if value else \"off\"
	node.self_modulate.a = 1.0 if value else 0.2


func text_update_on_edit():
	return true


func to_text(value) -> String:
	return \"ON\" if value else \"off\"


func from_text(text : String):
	if text.begins_with(\"O\"):
		return text == \"ON\"

	else:
		return text != \"off\"
"

[sub_resource type="GDScript" id="GDScript_8kbka"]
script/source = "extends ResourceTablesCellEditor


func can_edit_value(value, type, property_hint, column_index) -> bool:
	return type == TYPE_INT and property_hint == PROPERTY_HINT_ENUM


func set_value(node : Control, value):
	if value == null:
		# Sometimes, when creating new property, becomes null
		value = 0

	var value_str : String
	var key_found := -1
	var hint_arr : Array = hint_strings_array[node.get_index() % hint_strings_array.size()]
	for i in hint_arr.size():
		var colon_found : int = hint_arr[i].rfind(\":\")
		if colon_found == -1:
			key_found = value
			break

		if hint_arr[i].substr(colon_found + 1).to_int() == value:
			key_found = i
			break

	if key_found != -1 and key_found < hint_arr.size():
		value_str = hint_arr[key_found]

	else:
		value_str = \"?:%s\" % value

	node.text = value_str
	node.self_modulate = Color(node.text.hash()) + Color(0.25, 0.25, 0.25, 1.0)
	node.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER


func is_text():
	return false
"

[sub_resource type="GDScript" id="GDScript_bwsqh"]
script/source = "extends ResourceTablesCellEditor

const TablesPluginSettingsClass := preload(\"res://addons/resources_spreadsheet_view/settings_grid.gd\")

var previewer : EditorResourcePreview


func can_edit_value(value, type, property_hint, column_index) -> bool:
	return type == TYPE_OBJECT


func create_cell(caller : Control) -> Control:
	if previewer == null:
		previewer = caller.editor_plugin.get_editor_interface().get_resource_previewer()

	var node = load(CELL_SCENE_DIR + \"resource.tscn\").instantiate()
	return node


func set_value(node : Control, value):
	var preview_node := node.get_node(\"Box/Tex\")
	var label_node := node.get_node(\"Box/Label\")
	if value == null:
		preview_node.visible = false
		label_node.text = \"[empty]\"
		node.editor_description = \"\"

	if !value is Resource: return
	
	node.editor_description = value.resource_path
	label_node.text = _resource_to_string(value, ProjectSettings.get_setting(TablesPluginSettingsClass.PREFIX + \"resource_cell_label_mode\", 0))

	if value is Texture:
		preview_node.visible = true
		preview_node.texture = value

	else:
		preview_node.visible = false
		previewer.queue_resource_preview(value.resource_path, self, &\"_on_preview_loaded\", node)
		
	preview_node.custom_minimum_size = Vector2.ONE * ProjectSettings.get_setting(
		TablesPluginSettingsClass.PREFIX + \"resource_preview_size\"
	)


func set_color(node : Control, color : Color):
	node.get_node(\"Back\").modulate = color * 0.6 if node.editor_description == \"\" else color


func is_text():
	return false


func _on_preview_loaded(path : String, preview : Texture, thumbnail_preview : Texture, node):
	# Abort if the node has been deleted since.
	if is_instance_valid(node):
		node.get_node(\"Box/Tex\").visible = true
		node.get_node(\"Box/Tex\").texture = preview


static func _resource_to_string(res : Resource, cell_label_mode : int):
	var prefix := \"\"
	if cell_label_mode != 2:
		if res.has_method(&\"_to_string\"):
			prefix = res._to_string() + \"\\n\"

		elif res.has_method(&\"ToString\"):
			prefix = res.ToString() + \"\\n\"

	if cell_label_mode == 1 && !prefix.is_empty():
		return prefix.trim_suffix(\"\\n\")

	return prefix + (res.resource_name if res.resource_name != \"\" else \"[%s]\" % res.resource_path.get_file())
"

[sub_resource type="GDScript" id="GDScript_nhac0"]
script/source = "extends ResourceTablesCellEditor


func can_edit_value(value, type, property_hint, column_index) -> bool:
	return type == TYPE_FLOAT or type == TYPE_INT


func to_text(value) -> String:
	return str(value)


func from_text(text : String):
	return text.to_float()
"

[sub_resource type="GDScript" id="GDScript_x4vo1"]
script/source = "extends ResourceTablesCellEditor


func create_cell(caller : Control) -> Control:
	var cell_scene: Label = load(CELL_SCENE_DIR + \"basic.tscn\").instantiate()
	cell_scene.resized.connect(_resize_text.bind(cell_scene))
	return cell_scene

func _resize_text(cell: Label):
	var string_size = cell.get_theme_font(\"font\").get_string_size(cell.text, HORIZONTAL_ALIGNMENT_LEFT, -1, cell.get_theme_font_size(\"normal_font_size\"))
	var string_width = string_size.x
	var max_column_width = DisplayServer.window_get_size().x / 4
	if string_width >= max_column_width:
		cell.autowrap_mode = TextServer.AUTOWRAP_WORD
		cell.custom_minimum_size.x = max_column_width
	else:
		cell.autowrap_mode = TextServer.AUTOWRAP_OFF
		cell.custom_minimum_size.x = 24

func to_text(value) -> String:
	return str(value)


func from_text(text : String):
	return text


func set_color(node : Control, color : Color):
	node.get_node(\"Back\").modulate = color * 0.6
"

[node name="Control" type="MarginContainer"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
size_flags_horizontal = 3
size_flags_vertical = 3
focus_neighbor_left = NodePath(".")
focus_neighbor_top = NodePath(".")
focus_neighbor_right = NodePath(".")
focus_neighbor_bottom = NodePath(".")
focus_next = NodePath(".")
focus_previous = NodePath(".")
focus_mode = 2
theme_override_constants/margin_left = 3
theme_override_constants/margin_right = 3
theme_override_constants/margin_bottom = 5
script = SubResource("GDScript_w5ufo")
metadata/_edit_lock_ = true

[node name="HeaderContentSplit" type="VBoxContainer" parent="."]
layout_mode = 2

[node name="VBoxContainer" type="VBoxContainer" parent="HeaderContentSplit"]
layout_mode = 2

[node name="MenuStrip" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer"]
layout_mode = 2

[node name="File" type="Button" parent="HeaderContentSplit/VBoxContainer/MenuStrip"]
layout_mode = 2
tooltip_text = "Settings"
focus_mode = 0
toggle_mode = true
button_pressed = true
text = "File"
flat = true

[node name="SearchProcess" type="Button" parent="HeaderContentSplit/VBoxContainer/MenuStrip"]
layout_mode = 2
tooltip_text = "Settings"
focus_mode = 0
toggle_mode = true
button_pressed = true
text = "Filter/Process"
flat = true

[node name="VisibleCols" type="MenuButton" parent="HeaderContentSplit/VBoxContainer/MenuStrip"]
layout_mode = 2
text = "Shown Columns"

[node name="VSeparator" type="Control" parent="HeaderContentSplit/VBoxContainer/MenuStrip"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Settings" type="Button" parent="HeaderContentSplit/VBoxContainer/MenuStrip"]
layout_mode = 2
tooltip_text = "Settings"
focus_mode = 0
text = "Settings"
flat = true

[node name="VSeparator2" type="VSeparator" parent="HeaderContentSplit/VBoxContainer/MenuStrip"]
layout_mode = 2

[node name="Info" type="Button" parent="HeaderContentSplit/VBoxContainer/MenuStrip"]
layout_mode = 2
focus_mode = 0
text = "About"
flat = true

[node name="HBoxContainer" type="HSplitContainer" parent="HeaderContentSplit/VBoxContainer"]
layout_mode = 2
split_offset = -249

[node name="HBoxContainer" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3
theme_override_constants/separation = 0

[node name="ColorRect4" type="ColorRect" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer"]
modulate = Color(0, 0, 0, 1)
custom_minimum_size = Vector2(6, 18)
layout_mode = 2
script = SubResource("GDScript_geuqq")

[node name="TextureRect" type="TextureRect" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer/ColorRect4"]
layout_mode = 1
anchors_preset = 11
anchor_left = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = 48.0
grow_horizontal = 0
grow_vertical = 2
texture = SubResource("GradientTexture2D_18il8")
expand_mode = 1

[node name="ColorRect3" type="Control" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer"]
custom_minimum_size = Vector2(2, 0)
layout_mode = 2

[node name="Label" type="Label" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer"]
layout_mode = 2
text = "Resource Folder:"

[node name="Path" type="LineEdit" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
caret_blink = true

[node name="SelectDir" type="Button" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer"]
layout_mode = 2
tooltip_text = "Open Folder"
script = SubResource("GDScript_n6ief")
icon_name = "Folder"

[node name="DeletePath" type="Button" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer"]
layout_mode = 2
tooltip_text = "Remove Path from Recent"
script = SubResource("GDScript_n6ief")
icon_name = "Remove"

[node name="HBoxContainer2" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/HBoxContainer"]
layout_mode = 2

[node name="Label2" type="Label" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer2"]
layout_mode = 2
text = "Open Recent:"

[node name="RecentPaths" type="OptionButton" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer2"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 3
clip_text = true
fit_to_longest_item = false
script = SubResource("GDScript_hnhyx")

[node name="ImportExport" type="Button" parent="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer2"]
layout_mode = 2
text = "Import/Export CSV..."
script = SubResource("GDScript_n6ief")
icon_name = "TextFile"

[node name="Search" type="VBoxContainer" parent="HeaderContentSplit/VBoxContainer"]
layout_mode = 2
theme_override_constants/separation = 0

[node name="HBoxContainer" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/Search"]
layout_mode = 2

[node name="ColorRect4" type="ColorRect" parent="HeaderContentSplit/VBoxContainer/Search/HBoxContainer"]
modulate = Color(0, 0, 0, 1)
custom_minimum_size = Vector2(6, 18)
layout_mode = 2
size_flags_vertical = 5
script = SubResource("GDScript_geuqq")

[node name="TextureRect" type="TextureRect" parent="HeaderContentSplit/VBoxContainer/Search/HBoxContainer/ColorRect4"]
layout_mode = 1
anchors_preset = 11
anchor_left = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = 48.0
grow_horizontal = 0
grow_vertical = 2
texture = SubResource("GradientTexture2D_18il8")
expand_mode = 1

[node name="Label" type="Label" parent="HeaderContentSplit/VBoxContainer/Search/HBoxContainer"]
layout_mode = 2
text = "GDScript Filter and Process"

[node name="HSeparator" type="HSeparator" parent="HeaderContentSplit/VBoxContainer/Search/HBoxContainer"]
layout_mode = 2
size_flags_horizontal = 3

[node name="Search" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/Search"]
layout_mode = 2

[node name="ColorRect2" type="ColorRect" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
modulate = Color(0, 0, 0, 1)
custom_minimum_size = Vector2(6, 18)
layout_mode = 2
size_flags_vertical = 5
script = SubResource("GDScript_geuqq")

[node name="TextureRect" type="TextureRect" parent="HeaderContentSplit/VBoxContainer/Search/Search/ColorRect2"]
layout_mode = 1
anchors_preset = 11
anchor_left = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_right = 48.0
grow_horizontal = 0
grow_vertical = 2
texture = SubResource("GradientTexture2D_18il8")
expand_mode = 1

[node name="Label" type="Label" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2
text = "Condition:"

[node name="Label2" type="Label" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2
tooltip_text = "Enter an expression. The table only show rows where the expression returns `true`.

You can use `res.<property_name>` to get a property, and `index` to get row number. Hit ENTER to run the search.

Try out these:
- (res.number_property > 0 and res.number_property < 100)
- (res.text_property != \\\"\\\")
- (\\\"a\\\" in res.text_property)
- (index < 5)"
mouse_filter = 0
mouse_default_cursor_shape = 16
text = "(?)"

[node name="Filter" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2
size_flags_horizontal = 3
script = SubResource("GDScript_n7jxd")
editor_view_path = NodePath("../../../../..")
title = "func f(res : Resource, index : int):"
default_text = "true"
default_text_ml = "return true"
function_save_key = "filter"

[node name="VSeparator" type="VSeparator" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2

[node name="Class" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2
script = SubResource("GDScript_5btok")

[node name="Label5" type="Label" parent="HeaderContentSplit/VBoxContainer/Search/Search/Class"]
layout_mode = 2
text = "Class:"

[node name="Class" type="OptionButton" parent="HeaderContentSplit/VBoxContainer/Search/Search/Class"]
layout_mode = 2
clip_text = true
fit_to_longest_item = false

[node name="Label" type="Label" parent="HeaderContentSplit/VBoxContainer/Search/Search/Class"]
layout_mode = 2
text = "Sub:"

[node name="Subclasses" type="CheckBox" parent="HeaderContentSplit/VBoxContainer/Search/Search/Class"]
layout_mode = 2
tooltip_text = "Include Subclasses"
button_pressed = true

[node name="VSeparator2" type="VSeparator" parent="HeaderContentSplit/VBoxContainer/Search/Search/Class"]
layout_mode = 2

[node name="Label3" type="Label" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2
text = "Process:"

[node name="Label4" type="Label" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2
tooltip_text = "Enter an expression. The values in selected cells will be replaced with calculated new values.

You can use `value` to get the cell's value, `res.<property_name>` to get a property, `row_index` to get row number
and `cell_index` to get the cell's selection order. Hit ENTER to run the search.

These are some valid expressions:
- (res.property1 + res.property2)
- (res.property1.replace(\\\"old_string\\\", \\\"new_string\\\"))
- (load(\\\"res://path/to_resource.tres\\\"))

Don't forget quotation marks on strings and str() on non-strings."
mouse_filter = 0
mouse_default_cursor_shape = 16
text = "(?)"

[node name="Process" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/Search/Search"]
layout_mode = 2
size_flags_horizontal = 3
script = SubResource("GDScript_n7jxd")
editor_view_path = NodePath("../../../../..")
mode = 1
title = "func f(value : Var, res : Resource, all_res : Array[Resource], row_index : int):"
default_text = "value"
default_text_ml = "return value"
function_save_key = "process"

[node name="HBoxContainer3" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer"]
layout_mode = 2

[node name="Label" type="Label" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3"]
layout_mode = 2
text = "Grid"

[node name="Refresh" type="Button" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3"]
layout_mode = 2
tooltip_text = "Refresh"
script = SubResource("GDScript_n6ief")
icon_name = "Loop"

[node name="Pages" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3"]
layout_mode = 2
size_flags_horizontal = 3
script = SubResource("GDScript_qnmyd")

[node name="Label" type="Label" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages"]
layout_mode = 2
text = "Page:"

[node name="Scroll" type="ScrollContainer" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages"]
layout_mode = 2
size_flags_horizontal = 3
follow_focus = true
vertical_scroll_mode = 0

[node name="Pagelist" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages/Scroll"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Label2" type="Label" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages"]
layout_mode = 2
text = "Rows per page:"

[node name="LineEdit" type="SpinBox" parent="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages"]
layout_mode = 2
size_flags_vertical = 4
min_value = 2.0
max_value = 300.0
value = 50.0

[node name="Sep" type="Control" parent="HeaderContentSplit/VBoxContainer"]
layout_mode = 2

[node name="Columns" type="Control" parent="HeaderContentSplit/VBoxContainer"]
clip_contents = true
layout_mode = 2

[node name="Columns" type="HBoxContainer" parent="HeaderContentSplit/VBoxContainer/Columns"]
layout_mode = 0
theme_override_constants/separation = 0
script = SubResource("GDScript_w5ie1")
table_header_scene = SubResource("PackedScene_8w634")

[node name="Sep2" type="Control" parent="HeaderContentSplit/VBoxContainer"]
visible = false
layout_mode = 2

[node name="MarginContainer" type="MarginContainer" parent="HeaderContentSplit"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
mouse_filter = 2

[node name="FooterContentSplit" type="VBoxContainer" parent="HeaderContentSplit/MarginContainer"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="Panel" type="MarginContainer" parent="HeaderContentSplit/MarginContainer/FooterContentSplit"]
layout_mode = 2
size_flags_vertical = 3
mouse_filter = 2

[node name="Panel" type="Panel" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel"]
layout_mode = 2

[node name="Scroll" type="ScrollContainer" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel"]
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3

[node name="MarginContainer" type="MarginContainer" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/Scroll"]
layout_mode = 2

[node name="TableGrid" type="Container" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/Scroll/MarginContainer"]
layout_mode = 2
script = SubResource("GDScript_lvb0l")

[node name="Label" type="Label" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel"]
self_modulate = Color(1, 1, 1, 0.498039)
layout_mode = 2
size_flags_horizontal = 3
size_flags_vertical = 3
text = "No folder selected!
Please select a folder to edit using the text field or Open button above.

Then, Shift+Click or Ctrl+Click cells to edit them using the keyboard,
Inspector dock or this screen's bottom panels.

To find out keybindings available, open the \"About\" menu."
horizontal_alignment = 1
vertical_alignment = 1

[node name="FrozenColumns" type="Control" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel"]
clip_contents = true
layout_mode = 2
mouse_filter = 2

[node name="FrozenColumns" type="ColorRect" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/FrozenColumns"]
layout_mode = 1
size_flags_horizontal = 0
mouse_filter = 2
script = SubResource("GDScript_de2be")

[node name="Footer" type="VBoxContainer" parent="HeaderContentSplit/MarginContainer/FooterContentSplit"]
layout_mode = 2

[node name="PropertyEditors" type="VBoxContainer" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Footer"]
unique_name_in_owner = true
layout_mode = 2

[node name="EditEnumArray" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Footer/PropertyEditors" instance=ExtResource("8_234wn")]
visible = false
layout_mode = 2

[node name="EditArray" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Footer/PropertyEditors" instance=ExtResource("9_nts08")]
visible = false
layout_mode = 2

[node name="EditDict" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Footer/PropertyEditors" instance=ExtResource("13_il556")]
visible = false
layout_mode = 2

[node name="EditColor" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Footer/PropertyEditors" instance=ExtResource("10_nsma2")]
visible = false
layout_mode = 2

[node name="EditNumber" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Footer/PropertyEditors" instance=ExtResource("11_q1ao4")]
visible = false
layout_mode = 2

[node name="EditTexture" parent="HeaderContentSplit/MarginContainer/FooterContentSplit/Footer/PropertyEditors" instance=ExtResource("12_4kr6q")]
visible = false
layout_mode = 2

[node name="Control" type="Control" parent="."]
layout_mode = 2
mouse_filter = 2
metadata/_edit_lock_ = true

[node name="FileDialog" type="FileDialog" parent="Control"]
title = "Open"
size = Vector2i(800, 500)
min_size = Vector2i(800, 400)
ok_button_text = "Open"
mode_overrides_title = false
file_mode = 3
filters = PackedStringArray("*.tres", "*.res")

[node name="FileDialogText" type="FileDialog" parent="Control"]
title = "Open or Create Text File"
size = Vector2i(800, 500)
min_size = Vector2i(800, 400)
ok_button_text = "Open"
mode_overrides_title = false
file_mode = 3
filters = PackedStringArray("*.csv")

[node name="Info" type="AcceptDialog" parent="Control"]
title = "About"
size = Vector2i(800, 500)

[node name="MarginContainer" type="MarginContainer" parent="Control/Info"]
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 8.0
offset_top = 8.0
offset_right = -8.0
offset_bottom = -49.0
grow_horizontal = 2
grow_vertical = 2

[node name="Panel" type="Panel" parent="Control/Info/MarginContainer"]
layout_mode = 2

[node name="RichTextLabel" type="RichTextLabel" parent="Control/Info/MarginContainer"]
layout_mode = 2
bbcode_enabled = true
text = "Edit Resources as Table 2

\"Welp, it is what it sounds like!\"

Possible inputs:
- Ctrl + Click / Cmd + Click - Select multiple cells in one column
- Shift + Click - Select all cells between A and B in one column
- Up / Down / Shift+Tab / Tab - move cell selection up/down/left/right

- Left/Right - Move cursor along cell text
- Backspace/Delete - Erase text Left / Right from cursor
- Home/End - Move cursor to start/end of cell
- Ctrl + <move/erase> / Cmd + <move/erase> - Move through / Erase whole word

- Ctrl/Cmd + C/V - Copy cells / Paste text into cells 
- Ctrl/Cmd + (Shift) + Z - The Savior 
If clipboard contains as many lines as there are cells selected, each line is pasted into a separate cell.

Made by Don Tnowe. 2022.
https://twitter.com/don_tnowe
Issues and contribution:
https://github.com/don-tnowe/godot-resources-as-sheets-plugin"

[node name="Settings" type="AcceptDialog" parent="Control"]
title = "Settings"
size = Vector2i(500, 300)
min_size = Vector2i(500, 300)

[node name="Settings" parent="Control/Settings" instance=ExtResource("13_as1sh")]

[node name="ImportExport" type="Window" parent="Control"]
process_mode = 3
initial_position = 4
size = Vector2i(600, 400)
visible = false
transient = true
exclusive = true
min_size = Vector2i(600, 400)

[node name="ImportExport" parent="Control/ImportExport" instance=ExtResource("14_3p12b")]

[node name="SelectionActions" parent="Control" instance=ExtResource("23_m53sx")]
visible = false
layout_mode = 0
offset_left = -506.0
offset_top = 65.0
offset_right = -426.0
offset_bottom = 117.0

[node name="InputHandler" type="Node" parent="."]
script = SubResource("GDScript_1pwr0")

[node name="SelectionManager" type="Control" parent="."]
layout_mode = 2
mouse_filter = 2
script = SubResource("GDScript_x8y6m")
cell_editor_classes = Array[Script]([SubResource("GDScript_7gp0s"), SubResource("GDScript_fkfih"), SubResource("GDScript_kky4y"), SubResource("GDScript_sa58q"), SubResource("GDScript_eb48a"), SubResource("GDScript_8kbka"), SubResource("GDScript_bwsqh"), SubResource("GDScript_nhac0"), SubResource("GDScript_x4vo1")])
metadata/_edit_lock_ = true

[connection signal="grid_updated" from="." to="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages" method="_on_grid_updated"]
[connection signal="grid_updated" from="." to="HeaderContentSplit/MarginContainer/FooterContentSplit/Panel/FrozenColumns/FrozenColumns" method="_on_grid_updated"]
[connection signal="gui_input" from="." to="InputHandler" method="_gui_input"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/MenuStrip/File" to="." method="_on_File_pressed"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/MenuStrip/SearchProcess" to="." method="_on_SearchProcess_pressed"]
[connection signal="about_to_popup" from="HeaderContentSplit/VBoxContainer/MenuStrip/VisibleCols" to="HeaderContentSplit/VBoxContainer/Columns/Columns" method="_on_visible_cols_about_to_popup"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/MenuStrip/Settings" to="Control/Settings" method="popup_centered"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/MenuStrip/Info" to="Control/Info" method="popup_centered"]
[connection signal="text_submitted" from="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer/Path" to="." method="_on_path_text_submitted"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer/SelectDir" to="Control/FileDialog" method="popup_centered"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer/DeletePath" to="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer2/RecentPaths" method="remove_selected_path_from_recent"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/HBoxContainer/HBoxContainer2/ImportExport" to="Control/FileDialogText" method="popup_centered"]
[connection signal="pressed" from="HeaderContentSplit/VBoxContainer/HBoxContainer3/Refresh" to="." method="_on_path_text_submitted"]
[connection signal="value_changed" from="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages/LineEdit" to="HeaderContentSplit/VBoxContainer/HBoxContainer3/Pages" method="_on_LineEdit_value_changed"]
[connection signal="dir_selected" from="Control/FileDialog" to="." method="_on_FileDialog_dir_selected"]
[connection signal="file_selected" from="Control/FileDialog" to="." method="_on_FileDialog_dir_selected"]
[connection signal="dir_selected" from="Control/FileDialogText" to="Control/ImportExport/ImportExport" method="_on_file_selected"]
[connection signal="file_selected" from="Control/FileDialogText" to="Control/ImportExport/ImportExport" method="_on_file_selected"]
[connection signal="files_selected" from="Control/FileDialogText" to="Control/ImportExport/ImportExport" method="_on_files_selected"]
[connection signal="close_requested" from="Control/ImportExport" to="Control/ImportExport" method="hide"]
[connection signal="cells_rightclicked" from="SelectionManager" to="Control/SelectionActions" method="_on_grid_cells_rightclicked"]
[connection signal="cells_selected" from="SelectionManager" to="Control/SelectionActions" method="_on_grid_cells_selected"]
